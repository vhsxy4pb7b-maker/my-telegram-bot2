# 群名解析定义说明

## 📋 群名格式定义

### 基本规则

群名必须包含以下格式之一：
1. **老客户格式**: 10位连续数字
2. **新客户格式**: `A` + 10位连续数字

**重要**: 10位数字或 `A+10位数字` 可以在群名的**任意位置**，不一定是开头。

---

## 🔍 群名格式示例

### ✅ 有效格式

#### 老客户（10位数字）

| 群名示例 | 说明 |
|---------|------|
| `2506060110` | 标准格式（开头） |
| `测试 2506060110` | 前面有内容 |
| `2506060110 测试` | 后面有内容 |
| `测试 2506060110 其他内容` | 前后都有内容 |
| `2508220210（3）` | 后面有括号和数字 |
| `群组-2506060110-订单` | 中间有分隔符 |

#### 新客户（A + 10位数字）

| 群名示例 | 说明 |
|---------|------|
| `A2506060110` | 标准格式（开头） |
| `测试 A2506060110` | 前面有内容 |
| `A2506060110 测试` | 后面有内容 |
| `测试 A2506060110 其他内容` | 前后都有内容 |
| `新客户-A2506060110-订单` | 中间有分隔符 |

### ❌ 无效格式

| 群名示例 | 问题 |
|---------|------|
| `250606011` | 只有9位数字（需要10位） |
| `25060601101` | 有11位数字（需要10位） |
| `A250606011` | A后面只有9位数字 |
| `测试订单` | 没有10位数字 |
| `25060601 10` | 10位数字被空格分隔 |

---

## 🔢 10位数字解析规则

### 数字格式: `YYMMDDNNKK`

| 位置 | 长度 | 含义 | 示例 |
|------|------|------|----|
| YY | 2位 | 年份（后两位） | 25 = 2025 |
| MM | 2位 | 月份 | 06 = 6月 |
| DD | 2位 | 日期 | 06 = 6日 |
| NN | 2位 | 序号 | 01 = 序号1 |
| KK | 2位 | 金额（单位：千） | 10 = 10,000 |

### 解析示例

**订单ID**: `2506060110`

```
25 06 06 01 10
│  │  │  │  └─ 金额: 10 * 1000 = 10,000
│  │  │  └──── 序号: 01
│  │  └─────── 日期: 06日
│  └────────── 月份: 06月
└───────────── 年份: 2025年
```

**结果**:
- 订单日期: `2025-06-06`
- 订单金额: `10,000`
- 订单ID: `2506060110`（老客户）或 `A2506060110`（新客户）

---

## 💻 代码实现

### 解析函数

**位置**: `utils/order_helpers.py::parse_order_from_title()`

### 解析逻辑

```python
def parse_order_from_title(title: str):
    """从群名解析订单信息"""
    customer = 'B'  # 默认老客户
    raw_digits = None
    order_id = None

    # 1. 优先匹配新客户格式 (A + 10位数字)
    match_new = re.search(r'A(\d{10})', title)
    if match_new:
        customer = 'A'
        raw_digits = match_new.group(1)  # 提取10位数字
        order_id = match_new.group(0)    # A + 10位数字作为订单ID
    else:
        # 2. 匹配老客户格式 (10位连续数字)
        # 使用负向前瞻确保前面不是A，避免重复匹配
        match_old = re.search(r'(?<!A)(\d{10})(?!\d)', title)
        if match_old:
            customer = 'B'
            raw_digits = match_old.group(1)  # 提取10位数字
            order_id = match_old.group(1)    # 只有10位数字作为订单ID

    if not raw_digits:
        return None  # 无法解析

    # 3. 解析日期部分 (前6位: YYMMDD)
    date_part = raw_digits[:6]  # 250606
    full_date_str = f"20{date_part}"  # 20250606
    order_date = datetime.strptime(full_date_str, "%Y%m%d").date()

    # 4. 解析金额部分 (后2位: KK)
    amount_part = raw_digits[8:10]  # 10
    amount = int(amount_part) * 1000  # 10,000

    return {
        'date': order_date,
        'amount': amount,
        'order_id': order_id,
        'customer': customer,
        'full_date_str': full_date_str
    }
```

### 正则表达式说明

#### 新客户格式: `r'A(\d{10})'`
- `A` - 匹配字母 A
- `(\d{10})` - 匹配10位连续数字（捕获组）
- 可以在群名任意位置匹配

#### 老客户格式: `r'(?<!A)(\d{10})(?!\d)'`
- `(?<!A)` - 负向后顾断言，确保前面不是A
- `(\d{10})` - 匹配10位连续数字（捕获组）
- `(?!\d)` - 负向前瞻断言，确保后面不是数字
- 可以在群名任意位置匹配，但避免匹配A后面的10位数字

---

## 📊 解析流程图

```
群名输入
  ↓
检查是否包含 A + 10位数字
  ├─ 是 → 新客户 (A)
  │   └─ 提取: A + 10位数字
  │
  └─ 否 → 检查是否包含 10位连续数字
      ├─ 是 → 老客户 (B)
      │   └─ 提取: 10位数字
      │
      └─ 否 → 返回 None（无法解析）
          ↓
解析10位数字
  ├─ 前6位 (YYMMDD) → 订单日期
  └─ 后2位 (KK) → 订单金额
          ↓
返回解析结果
  ├─ order_id: 订单ID
  ├─ customer: 客户类型 (A/B)
  ├─ date: 订单日期
  ├─ amount: 订单金额
  └─ full_date_str: 完整日期字符串
```

---

## 🧪 测试用例

### 测试1: 标准格式

```python
群名: "2506060110"
结果:
  - 订单ID: "2506060110"
  - 客户类型: B (老客户)
  - 订单日期: 2025-06-06
  - 订单金额: 10,000
```

### 测试2: 新客户格式

```python
群名: "A2506060110"
结果:
  - 订单ID: "A2506060110"
  - 客户类型: A (新客户)
  - 订单日期: 2025-06-06
  - 订单金额: 10,000
```

### 测试3: 包含其他内容

```python
群名: "测试 2506060110 其他内容"
结果:
  - 订单ID: "2506060110"
  - 客户类型: B (老客户)
  - 订单日期: 2025-06-06
  - 订单金额: 10,000
```

### 测试4: 包含括号

```python
群名: "2508220210（3）"
结果:
  - 订单ID: "2508220210"
  - 客户类型: B (老客户)
  - 订单日期: 2025-08-22
  - 订单金额: 10,000
```

### 测试5: 新客户包含其他内容

```python
群名: "测试 A2506060110 其他"
结果:
  - 订单ID: "A2506060110"
  - 客户类型: A (新客户)
  - 订单日期: 2025-06-06
  - 订单金额: 10,000
```

---

## ⚠️ 注意事项

### 1. 数字必须连续

- ✅ `2506060110` - 10位连续数字
- ❌ `25060601 10` - 被空格分隔，无法匹配

### 2. 新客户格式优先级

- 如果群名同时包含 `A2506060110` 和 `2506060110`，优先匹配新客户格式

### 3. 避免重复匹配

- 使用负向后顾断言 `(?<!A)` 确保不会将 `A2506060110` 中的 `2506060110` 误匹配为老客户

### 4. 日期验证

- 解析后的日期必须有效（例如：不能是 2025-13-45）
- 无效日期会导致解析失败

### 5. 金额计算

- 后2位数字直接乘以1000
- 例如：`10` → `10,000`，`05` → `5,000`

---

## 🔧 解析失败处理

### 失败原因

1. **群名中没有10位连续数字**
   - 手动触发：显示错误消息
   - 自动触发：记录日志，不创建订单

2. **日期无效**
   - 例如：`2506130110`（6月没有31日）
   - 解析失败，返回 `None`

3. **格式不符合**
   - 数字位数不对（不是10位）
   - 新客户格式中A后面不是10位数字

### 错误消息

**手动触发时**:
```
❌ Invalid Group Title Format.

Expected:
1. Old Customer: 10 digits (e.g., 2401150105)
2. New Customer: A + 10 digits (e.g., A2401150105)

Current title: [群名]
```

**自动触发时**:
- 记录日志：`Group title '[群名]' does not match order pattern`
- 不显示错误消息给用户

---

## 📝 完整解析示例

### 示例1: 老客户订单

```
输入群名: "2506060110（3）"

解析步骤:
1. 检查新客户格式: 无匹配
2. 检查老客户格式: 匹配到 "2506060110"
3. 提取10位数字: "2506060110"
4. 解析日期: 前6位 "250606" → 2025-06-06
5. 解析金额: 后2位 "10" → 10,000

返回结果:
{
    'order_id': '2506060110',
    'customer': 'B',
    'date': date(2025, 6, 6),
    'amount': 10000,
    'full_date_str': '20250606'
}
```

### 示例2: 新客户订单

```
输入群名: "测试 A2506060110 其他内容"

解析步骤:
1. 检查新客户格式: 匹配到 "A2506060110"
2. 提取10位数字: "2506060110"
3. 解析日期: 前6位 "250606" → 2025-06-06
4. 解析金额: 后2位 "10" → 10,000

返回结果:
{
    'order_id': 'A2506060110',
    'customer': 'A',
    'date': date(2025, 6, 6),
    'amount': 10000,
    'full_date_str': '20250606'
}
```

---

## ✅ 总结

群名解析的核心规则：

1. **格式要求**: 群名中必须包含10位连续数字或 `A+10位连续数字`
2. **位置灵活**: 10位数字可以在群名的任意位置
3. **数字格式**: `YYMMDDNNKK`（年份、月份、日期、序号、金额）
4. **客户识别**: 
   - `A+10位数字` → 新客户 (A)
   - `10位数字` → 老客户 (B)
5. **解析失败**: 返回 `None`，不创建订单

解析逻辑设计合理，支持灵活的群名格式，同时确保数据准确性。

